# Section1. 타입스크립트 개론

## 타입스크립트를 소개합니다

***타입스크립트*** 

자바스크립트의 확장판 , 자바스크립트를 더 안전하게 사용할 수 있도록 ‘타입 관련 기능들을 추가한’ 언어

**JS도 잘 나가는데 굳이 TS가 필요할까?** 

→ JS는 아주 간단한 상호작용을 처리하기 위해 개발되었기 때문에 유연한 문법을 가진 대신 버그 발생 가능성이 높음. 웹 브라우저에서만 실행되던 JS가 node.js의 탄생 이후로 웹 서버, 모바일 앱, 데스크탑 앱을 만드는 데에도 활용되는데 높은 버그 발생 가능성으로 인해 프로그램의 안정성을 떨어트림 

→ JS의 문법과 기존의 매력을 유지하면서 안정성을 확보한 언어가 필요해짐 →TS의 등장

## 자바스크립트의 한계점과 타입스크립트

***자바스크립트에는 정확히 어떤 한계점이 있는가?***

배경지식

**타입 시스템** : 모든 프로그래밍 언어는 타입 시스템을 가지고 있음, 값들을 어떤 기준으로 묶어 타입을 규정할 것인가? 코드의 타입을 언제 검사할지? 어떻게 타입을 검사할지? 등과 같은 규칙들을 모아둔 체계. 즉, 언어의 타입 관련된 문법 체계

- 정적 타입 시스템
    
     = 코드 실행 이전 모든 변수의 타입을 고정적으로 결정함 (엄격하고 고정적인 시스템 ex: C, Java)
    
- 동적 타입 시스템
    
    = 코드를 실행하고 나서 그 때 그 때마다 유동적으로 변수의 타입을 결정함 (자유롭고 유연한 시스템 ex: Python, JavaScript ) 
    

JS with 동적 타입 시스템 

변수의 타입들을 코드가 실행되는 도중에 결정함 

→변수의 타입을 우리가 직접 정의하지 않음;

변수의 타입이 하나로만 고정되지 않음 = 아무 타입의 값이나 자유롭게 담을 수 있음 

→ 실행은 되지만 Type Error 발생 

⇒오류가 발생한 코드를 검사하고 실행되지 않도록 하는 것이 좋음! 

***타입스크립트는 이 한계점을 어떻게 극복하고 어떤 차별점을 갖는가?***

독특한 타입 시스템 사용!

동적 타입 시스템 + 정적 타입 시스템

- 변수의 타입을 실행 전에 결정
- 타입 오류를 실행 전에 검사
- 모든 변수에 타입을 일일이 지정할 필요가 없음 (= 점진적 타입 시스템 (Gradual Type System)
    
    결론적으로, 정적 타입의 안정성을 채택하면서도 정적 타입의 귀찮음을 해소하는 셈
    

![Untitled](Section1%20%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%B8%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B8%E1%84%90%E1%85%B3%20%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%2016c95ab9e32949dc9a9f90dd849675d3/Untitled.png)

## 타입스크립트의 동작원리

***타입스트립트는 어떤 과정을 거쳐 동작할까?***

***왜 그렇게 동작하는 걸까?***

다른 언어들의 compile 과정 

js → ast (추상 문법 트리) → 바이트 코드

타입스크립트의 compile 과정

ts → ast(추상 문법 트리) → 타입 검사 (Type Checking) - 검사 실패 시 컴파일 종료 

                                                                                 └ 검사 성공 시 AST를 js로 변환

![Untitled](Section1%20%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%B8%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B8%E1%84%90%E1%85%B3%20%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%2016c95ab9e32949dc9a9f90dd849675d3/Untitled%201.png)

![Untitled](Section1%20%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%B8%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B8%E1%84%90%E1%85%B3%20%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%2016c95ab9e32949dc9a9f90dd849675d3/Untitled%202.png)

결론적으로 타입과 관련된 코드들은 컴파일 후에 사라지기 때문에 프로그램 실행 자체에는 영향을 미치지 않는다.

## Hello TS World!

```jsx
$ npm i @types/node   ->package.json 생성 됨.
$ npm install typescript -g 
$ tsc -v               
```

tsc -v에서 에러 발생하는 경우

```bash
$ Set-ExecutionPolicy -Scope CurrentUser
//Unrestricted 입력
```

ts로 작성한 코드 컴파일 및 실행

```bash
$ tsc src/index.ts
$ node src/indext.js
```

⇒ 해당 작업을 한 번에 실행하기 위해 tsx 라이브러리 설치

```bash
$ npm install tsx -g
```

tsx로 ts 코드 컴파일 및 실행

```bash
$ tsx src/index.ts
```

## TS 컴파일러 옵션 설정하기

TS → JS 컴파일 옵션 (프로젝트의 성격에 따라 다르게 설정)

- 얼마나 엄격하게 타입 오류를 검사할지,
- JS 코드의 버전은 어떻게 할지

컴파일러 옵션 초기화

```bash
$ tsc --init
```

해당 명령어 작성 시, tsconfig.json 파일이 생성 됨. 

→ 전부 다 지우고 재작성

```json
{
  "compilerOptions": {
    "target": "ESNext",     //어떤 version의 js로 compile 할 건지
    "module": "ESNext",   //어떤 module system으로 compile할 건지
		"outDir": "dist"
  },
	"ts-node": {
    "esm": true
  },
  "include":["src"]     //컴파일 할 파일의 경로를 적어줌 ->'src'아래의 파일들을 전부 compile하겠다.
}
```

/module 관련 부분 다시 수강하고 자료 요약해야 함.